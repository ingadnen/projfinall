{"ast":null,"code":"var _jsxFileName = \"/Users/m/projetfinal/src/App.js\";\nimport React, { Component } from \"react\";\nimport \"./App.css\";\nimport Point from \"./point\";\nimport NavBar from \"./navbar\";\nimport { dijkstra, getPointsInShortestPathOrderDijkstra } from \"./Algorithm/dijkstra\";\nconst initialNum = getInitialNum(window.innerWidth, window.innerHeight);\nconst initialNumRows = initialNum[0];\nconst initialNumColumns = initialNum[1];\nconst startEndPoint = getStartEndPoint(initialNumRows, initialNumColumns);\nconst startPointRow = startEndPoint[0];\nconst startPointCol = startEndPoint[1];\nconst endPointRow = startEndPoint[2];\nconst endPointCol = startEndPoint[3];\n\nclass App extends Component {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      visualizingAlgorithm: false,\n      width: window.innerWidth,\n      height: window.innerHeight,\n      numRows: initialNumRows,\n      numColumns: initialNumColumns,\n      speed: 10\n    };\n\n    this.updateDimensions = () => {\n      this.setState({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    };\n  }\n\n  componentDidMount() {\n    window.addEventListener(\"resize\", this.updateDimensions);\n    const grid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({\n      grid\n    });\n  }\n\n  visualizeDijkstra() {\n    if (this.state.visualizingAlgorithm) {\n      return;\n    }\n\n    this.setState({\n      visualizingAlgorithm: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startPoint = grid[startPointRow][startPointCol];\n      const endPoint = grid[endPointRow][endPointCol];\n      const checkedPointsInOrder = dijkstra(grid, startPoint, endPoint);\n      const pointsInShortestPathOrder = getPointsInShortestPathOrderDijkstra(endPoint);\n      this.animateAlgorithm(checkedPointsInOrder, pointsInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n  render() {\n    let {\n      grid\n    } = this.state;\n    return /*#__PURE__*/React.createElement(React.Fragment, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 73,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(NavBar, {\n      visualizingAlgorithm: this.state.visualizingAlgorithm,\n      visualizeDijkstra: this.visualizeDijkstra.bind(this),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 74,\n        columnNumber: 11\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: this.state.visualizingAlgorithm ? \"grid-visualizing\" : \"grid\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 78,\n        columnNumber: 11\n      }\n    }, grid.map((row, rowId) => {\n      return /*#__PURE__*/React.createElement(\"div\", {\n        key: rowId,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 87,\n          columnNumber: 19\n        }\n      }, row.map((point, pointId) => {\n        const {\n          row,\n          col,\n          isStart,\n          isEnd,\n          isChecked,\n          isShortest\n        } = point;\n        return /*#__PURE__*/React.createElement(Point, {\n          key: pointId,\n          row: row,\n          col: col,\n          isStart: isStart,\n          isEnd: isEnd,\n          isChecked: isChecked,\n          isShortest: isShortest,\n          width: this.state.width,\n          height: this.state.height,\n          numRows: this.state.numRows,\n          numColumns: this.state.numColumns,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 98,\n            columnNumber: 27\n          }\n        });\n      }));\n    })));\n  }\n\n}\n\nfunction getInitialNum(width, height) {\n  let numColumns;\n\n  if (width > 1500) {\n    numColumns = Math.floor(width / 25);\n  } else if (width > 1250) {\n    numColumns = Math.floor(width / 22.5);\n  } else if (width > 1000) {\n    numColumns = Math.floor(width / 20);\n  } else if (width > 750) {\n    numColumns = Math.floor(width / 17.5);\n  } else if (width > 500) {\n    numColumns = Math.floor(width / 15);\n  } else if (width > 250) {\n    numColumns = Math.floor(width / 12.5);\n  } else if (width > 0) {\n    numColumns = Math.floor(width / 10);\n  }\n\n  let cercleWidth = Math.floor(width / numColumns);\n  let numRows = Math.floor(height / cercleWidth);\n  return [numRows, numColumns];\n}\n\nfunction getRandomNums(num) {\n  let randomNums1 = [];\n  let temp = 2;\n\n  for (let i = 5; i < num / 2; i += 2) {\n    randomNums1.push(temp);\n    temp += 2;\n  }\n\n  let randomNums2 = [];\n  temp = -2;\n\n  for (let i = num / 2; i < num - 5; i += 2) {\n    randomNums2.push(temp);\n    temp -= 2;\n  }\n\n  return [randomNums1, randomNums2];\n}\n\nfunction getStartEndPoint(numRows, numColumns) {\n  let randomNums;\n  let x;\n  let y;\n  let startPointRow;\n  let startPointCol;\n  let endPointRow;\n  let endPointCol;\n\n  if (numRows < numColumns) {\n    randomNums = getRandomNums(numRows);\n    x = Math.floor(numRows / 2);\n    y = Math.floor(numColumns / 4);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startPointRow = x + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    startPointCol = y + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    endPointRow = x + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n    endPointCol = numColumns - y + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n  } else {\n    randomNums = getRandomNums(numColumns);\n    x = Math.floor(numRows / 4);\n    y = Math.floor(numColumns / 2);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startPointRow = x + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    startPointCol = y + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    endPointRow = numRows - x + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n    endPointCol = y + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n  }\n\n  return [startPointRow, startPointCol, endPointRow, endPointCol];\n}\n\nconst getInitialGrid = (numRows, numColumns) => {\n  let grid = [];\n\n  for (let row = 0; row < numRows; row++) {\n    let currentRow = [];\n\n    for (let col = 0; col < numColumns; col++) {\n      currentRow.push(createPoint(row, col));\n    }\n\n    grid.push(currentRow);\n  }\n\n  return grid;\n};\n\nconst createPoint = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === startPointRow && col === startPointCol,\n    isEnd: row === endPointRow && col === endPointCol,\n    distance: Infinity,\n    totalDistance: Infinity,\n    isChecked: false,\n    isShortest: false,\n    previousPoint: null\n  };\n};\n\nexport default App;","map":{"version":3,"sources":["/Users/m/projetfinal/src/App.js"],"names":["React","Component","Point","NavBar","dijkstra","getPointsInShortestPathOrderDijkstra","initialNum","getInitialNum","window","innerWidth","innerHeight","initialNumRows","initialNumColumns","startEndPoint","getStartEndPoint","startPointRow","startPointCol","endPointRow","endPointCol","App","state","grid","mouseIsPressed","visualizingAlgorithm","width","height","numRows","numColumns","speed","updateDimensions","setState","componentDidMount","addEventListener","getInitialGrid","visualizeDijkstra","setTimeout","startPoint","endPoint","checkedPointsInOrder","pointsInShortestPathOrder","animateAlgorithm","render","bind","map","row","rowId","point","pointId","col","isStart","isEnd","isChecked","isShortest","Math","floor","cercleWidth","getRandomNums","num","randomNums1","temp","i","push","randomNums2","randomNums","x","y","random","length","currentRow","createPoint","distance","Infinity","totalDistance","previousPoint"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport \"./App.css\";\nimport Point from \"./point\";\nimport NavBar from \"./navbar\";\n\n\nimport {\n  dijkstra,\n  getPointsInShortestPathOrderDijkstra,\n} from \"./Algorithm/dijkstra\";\n\n\nconst initialNum = getInitialNum(window.innerWidth, window.innerHeight);\nconst initialNumRows = initialNum[0];\nconst initialNumColumns = initialNum[1];\n\nconst startEndPoint = getStartEndPoint(initialNumRows, initialNumColumns);\nconst startPointRow = startEndPoint[0];\nconst startPointCol = startEndPoint[1];\nconst endPointRow = startEndPoint[2];\nconst endPointCol = startEndPoint[3];\n\nclass App extends Component {\n  state = {\n    grid: [],\n    mouseIsPressed: false,\n    visualizingAlgorithm: false,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    numRows: initialNumRows,\n    numColumns: initialNumColumns,\n    speed: 10,\n  };\n\n  updateDimensions = () => {\n    this.setState({\n      width: window.innerWidth,\n      height: window.innerHeight,\n    });\n  };\n\n\n\n  componentDidMount() {\n    window.addEventListener(\"resize\", this.updateDimensions);\n    const grid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({ grid });\n  }\n\n\n  visualizeDijkstra() {\n    if (this.state.visualizingAlgorithm ) {\n      return;\n    }\n    this.setState({ visualizingAlgorithm: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startPoint = grid[startPointRow][startPointCol];\n      const endPoint = grid[endPointRow][endPointCol];\n      const checkedPointsInOrder = dijkstra(grid, startPoint, endPoint);\n      const pointsInShortestPathOrder = getPointsInShortestPathOrderDijkstra(\n          endPoint\n      );\n      this.animateAlgorithm(checkedPointsInOrder, pointsInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n\n\n  render() {\n    let { grid } = this.state;\n    return (\n        <React.Fragment>\n          <NavBar\n              visualizingAlgorithm={this.state.visualizingAlgorithm}\n              visualizeDijkstra={this.visualizeDijkstra.bind(this)}\n          />\n          <div\n              className={\n                this.state.visualizingAlgorithm\n                    ? \"grid-visualizing\"\n                    : \"grid\"\n              }\n          >\n            {grid.map((row, rowId) => {\n              return (\n                  <div key={rowId}>\n                    {row.map((point, pointId) => {\n                      const {\n                        row,\n                        col,\n                        isStart,\n                        isEnd,\n                        isChecked,\n                        isShortest,\n                      } = point;\n                      return (\n                          <Point\n                              key={pointId}\n                              row={row}\n                              col={col}\n                              isStart={isStart}\n                              isEnd={isEnd}\n                              isChecked={isChecked}\n                              isShortest={isShortest}\n                              width={this.state.width}\n                              height={this.state.height}\n                              numRows={this.state.numRows}\n                              numColumns={this.state.numColumns}\n                          ></Point>\n                      );\n                    })}\n                  </div>\n              );\n            })}\n          </div>\n        </React.Fragment>\n    );\n  }\n}\n\nfunction getInitialNum(width, height) {\n  let numColumns;\n  if (width > 1500) {\n    numColumns = Math.floor(width / 25);\n  } else if (width > 1250) {\n    numColumns = Math.floor(width / 22.5);\n  } else if (width > 1000) {\n    numColumns = Math.floor(width / 20);\n  } else if (width > 750) {\n    numColumns = Math.floor(width / 17.5);\n  } else if (width > 500) {\n    numColumns = Math.floor(width / 15);\n  } else if (width > 250) {\n    numColumns = Math.floor(width / 12.5);\n  } else if (width > 0) {\n    numColumns = Math.floor(width / 10);\n  }\n  let cercleWidth = Math.floor(width / numColumns);\n  let numRows = Math.floor(height / cercleWidth);\n  return [numRows, numColumns];\n}\n\nfunction getRandomNums(num) {\n  let randomNums1 = [];\n  let temp = 2;\n  for (let i = 5; i < num / 2; i += 2) {\n    randomNums1.push(temp);\n    temp += 2;\n  }\n  let randomNums2 = [];\n  temp = -2;\n  for (let i = num / 2; i < num - 5; i += 2) {\n    randomNums2.push(temp);\n    temp -= 2;\n  }\n  return [randomNums1, randomNums2];\n}\n\nfunction getStartEndPoint(numRows, numColumns) {\n  let randomNums;\n  let x;\n  let y;\n  let startPointRow;\n  let startPointCol;\n  let endPointRow;\n  let endPointCol;\n  if (numRows < numColumns) {\n    randomNums = getRandomNums(numRows);\n    x = Math.floor(numRows / 2);\n    y = Math.floor(numColumns / 4);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startPointRow =\n        x + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    startPointCol = y + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    endPointRow =\n        x + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n    endPointCol =\n        numColumns - y + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n  } else {\n    randomNums = getRandomNums(numColumns);\n    x = Math.floor(numRows / 4);\n    y = Math.floor(numColumns / 2);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startPointRow = x + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    startPointCol =\n        y + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    endPointRow = numRows - x + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n    endPointCol =\n        y + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n  }\n  return [startPointRow, startPointCol, endPointRow, endPointCol];\n}\n\nconst getInitialGrid = (numRows, numColumns) => {\n  let grid = [];\n  for (let row = 0; row < numRows; row++) {\n    let currentRow = [];\n    for (let col = 0; col < numColumns; col++) {\n      currentRow.push(createPoint(row, col));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createPoint = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === startPointRow && col === startPointCol,\n    isEnd: row === endPointRow && col === endPointCol,\n    distance: Infinity,\n    totalDistance: Infinity,\n    isChecked: false,\n    isShortest: false,\n    previousPoint: null,\n  };\n};\n\n\nexport default App;\n\n"]},"metadata":{},"sourceType":"module"}