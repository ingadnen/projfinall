{"ast":null,"code":"var _jsxFileName = \"/Users/m/projetfinal/src/App.js\";\nimport React, { Component } from \"react\";\nimport \"./App.css\";\nimport Node from \"./node\";\nimport NavBar from \"./navbar\"; //Algorithms\n\nimport { dijkstra, getPointsInShortestPathOrderDijkstra } from \"./Algorithm/dijkstra\";\nconst initialNum = getInitialNum(window.innerWidth, window.innerHeight);\nconst initialNumRows = initialNum[0];\nconst initialNumColumns = initialNum[1];\nconst startendPoint = getStartEndPoint(initialNumRows, initialNumColumns);\nconst startPointRow = startendPoint[0];\nconst startPointCol = startendPoint[1];\nconst endPointRow = startendPoint[2];\nconst endPointCol = startendPoint[3];\n\nclass App extends Component {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      visualizingAlgorithm: false,\n      width: window.innerWidth,\n      height: window.innerHeight,\n      numRows: initialNumRows,\n      numColumns: initialNumColumns,\n      speed: 10,\n      mazeSpeed: 10\n    };\n\n    this.updateDimensions = () => {\n      this.setState({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    };\n\n    this.updateSpeed = (path, maze) => {\n      this.setState({\n        speed: path,\n        mazeSpeed: maze\n      });\n    };\n\n    this.animateShortestPath = (pointsInShortestPathOrder, checkedPointsInOrder) => {\n      if (pointsInShortestPathOrder.length === 1) this.setState({\n        visualizingAlgorithm: false\n      });\n\n      for (let i = 1; i < pointsInShortestPathOrder.length; i++) {\n        if (i === pointsInShortestPathOrder.length - 1) {\n          setTimeout(() => {\n            let newGrid = updatePointsForRender(this.state.grid, pointsInShortestPathOrder, checkedPointsInOrder);\n            this.setState({\n              grid: newGrid,\n              visualizingAlgorithm: false\n            });\n          }, i * (3 * this.state.speed));\n          return;\n        }\n\n        let point = pointsInShortestPathOrder[i];\n        setTimeout(() => {\n          //shortest path point\n          document.getElementById(`node-${point.row}-${point.col}`).className = \"node node-shortest-path\";\n        }, i * (3 * this.state.speed));\n      }\n    };\n\n    this.animateAlgorithm = (checkedPointsInOrder, pointsInShortestPathOrder) => {\n      let newGrid = this.state.grid.slice();\n\n      for (let row of newGrid) {\n        for (let point of row) {\n          let newPoint = { ...point,\n            isVisited: false\n          };\n          newGrid[point.row][point.col] = newPoint;\n        }\n      }\n\n      this.setState({\n        grid: newGrid\n      });\n\n      for (let i = 1; i <= checkedPointsInOrder.length; i++) {\n        let point = checkedPointsInOrder[i];\n\n        if (i === checkedPointsInOrder.length) {\n          setTimeout(() => {\n            this.animateShortestPath(pointsInShortestPathOrder, checkedPointsInOrder);\n          }, i * this.state.speed);\n          return;\n        }\n\n        setTimeout(() => {\n          //checked point\n          document.getElementById(`node-${point.row}-${point.col}`).className = \"node node-visited\";\n        }, i * this.state.speed);\n      }\n    };\n  }\n\n  componentDidMount() {\n    window.addEventListener(\"resize\", this.updateDimensions);\n    const grid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({\n      grid\n    });\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n    this.setState({\n      grid: newGrid,\n      mouseIsPressed: true\n    });\n  }\n\n  handleMouseEnter(row, col) {\n    if (this.state.mouseIsPressed) {\n      const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n      this.setState({\n        grid: newGrid,\n        mouseIsPressed: true\n      });\n    }\n  }\n\n  handleMouseUp() {\n    this.setState({\n      mouseIsPressed: false\n    });\n  }\n\n  clearGrid() {\n    if (this.state.visualizingAlgorithm) {\n      return;\n    }\n\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (!(row === startPointRow && col === startPointCol || row === endPointRow && col === endPointCol)) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n\n    const newGrid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false\n    });\n  }\n\n  clearPath() {\n    if (this.state.visualizingAlgorithm) {\n      return;\n    }\n\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (document.getElementById(`node-${row}-${col}`).className === \"node node-shortest-path\") {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n\n    const newGrid = getGridWithoutPath(this.state.grid);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false\n    });\n  }\n\n  visualizeDijkstra() {\n    if (this.state.visualizingAlgorithm) {\n      return;\n    }\n\n    this.setState({\n      visualizingAlgorithm: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startPoint = grid[startPointRow][startPointCol];\n      const endPoint = grid[endPointRow][endPointCol];\n      const checkedPointsInOrder = dijkstra(grid, startPoint, endPoint);\n      const pointsInShortestPathOrder = getPointsInShortestPathOrderDijkstra(endPoint);\n      this.animateAlgorithm(checkedPointsInOrder, pointsInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n  render() {\n    let {\n      grid\n    } = this.state;\n    return /*#__PURE__*/React.createElement(React.Fragment, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 193,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(NavBar, {\n      visualizingAlgorithm: this.state.visualizingAlgorithm,\n      visualizeDijkstra: this.visualizeDijkstra.bind(this),\n      clearGrid: this.clearGrid.bind(this),\n      clearPath: this.clearPath.bind(this),\n      updateSpeed: this.updateSpeed.bind(this),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 194,\n        columnNumber: 11\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: this.state.visualizingAlgorithm ? \"grid-visualizing\" : \"grid\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 203,\n        columnNumber: 11\n      }\n    }, grid.map((row, rowId) => {\n      return /*#__PURE__*/React.createElement(\"div\", {\n        key: rowId,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 212,\n          columnNumber: 19\n        }\n      }, row.map((point, pointId) => {\n        const {\n          row,\n          col,\n          isStart,\n          isFinish,\n          isVisited,\n          isShortest,\n          isWall\n        } = point;\n        return /*#__PURE__*/React.createElement(Node, {\n          key: pointId,\n          row: row,\n          col: col,\n          isStart: isStart,\n          isFinish: isFinish,\n          isVisited: isVisited,\n          isShortest: isShortest,\n          isWall: isWall,\n          onMouseDown: (row, col) => this.handleMouseDown(row, col),\n          onMouseEnter: (row, col) => this.handleMouseEnter(row, col),\n          onMouseUp: () => this.handleMouseUp(),\n          width: this.state.width,\n          height: this.state.height,\n          numRows: this.state.numRows,\n          numColumns: this.state.numColumns,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 224,\n            columnNumber: 27\n          }\n        });\n      }));\n    })));\n  }\n\n}\n\nfunction getInitialNum(width, height) {\n  let numColumns;\n\n  if (width > 1500) {\n    numColumns = Math.floor(width / 25);\n  } else if (width > 1250) {\n    numColumns = Math.floor(width / 22.5);\n  } else if (width > 1000) {\n    numColumns = Math.floor(width / 20);\n  } else if (width > 750) {\n    numColumns = Math.floor(width / 17.5);\n  } else if (width > 500) {\n    numColumns = Math.floor(width / 15);\n  } else if (width > 250) {\n    numColumns = Math.floor(width / 12.5);\n  } else if (width > 0) {\n    numColumns = Math.floor(width / 10);\n  }\n\n  let cellWidth = Math.floor(width / numColumns);\n  let numRows = Math.floor(height / cellWidth);\n  return [numRows, numColumns];\n}\n\nfunction getRandomNums(num) {\n  let randomNums1 = [];\n  let temp = 2;\n\n  for (let i = 5; i < num / 2; i += 2) {\n    randomNums1.push(temp);\n    temp += 2;\n  }\n\n  let randomNums2 = [];\n  temp = -2;\n\n  for (let i = num / 2; i < num - 5; i += 2) {\n    randomNums2.push(temp);\n    temp -= 2;\n  }\n\n  return [randomNums1, randomNums2];\n}\n\nfunction getStartEndPoint(numRows, numColumns) {\n  let randomNums;\n  let x;\n  let y;\n  let startPointRow;\n  let startPointCol;\n  let endPointRow;\n  let endPointCol;\n\n  if (numRows < numColumns) {\n    randomNums = getRandomNums(numRows);\n    x = Math.floor(numRows / 2);\n    y = Math.floor(numColumns / 4);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startPointRow = x + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    startPointCol = y + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    endPointRow = x + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n    endPointCol = numColumns - y + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n  } else {\n    randomNums = getRandomNums(numColumns);\n    x = Math.floor(numRows / 4);\n    y = Math.floor(numColumns / 2);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startPointRow = x + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    startPointCol = y + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    endPointRow = numRows - x + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n    endPointCol = y + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n  }\n\n  return [startPointRow, startPointCol, endPointRow, endPointCol];\n}\n\nconst getInitialGrid = (numRows, numColumns) => {\n  let grid = [];\n\n  for (let row = 0; row < numRows; row++) {\n    let currentRow = [];\n\n    for (let col = 0; col < numColumns; col++) {\n      currentRow.push(createPoint(row, col));\n    }\n\n    grid.push(currentRow);\n  }\n\n  return grid;\n};\n\nconst createPoint = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === startPointRow && col === startPointCol,\n    isFinish: row === endPointRow && col === endPointCol,\n    distance: Infinity,\n    totalDistance: Infinity,\n    isVisited: false,\n    isShortest: false,\n    isWall: false,\n    previousPoint: null\n  };\n};\n\nconst getNewGridWithWalls = (grid, row, col) => {\n  let newGrid = grid.slice();\n  let point = grid[row][col];\n  let newPoint = { ...point,\n    isWall: !point.isWall\n  };\n  newGrid[row][col] = newPoint;\n  return newGrid;\n};\n\nconst getGridWithoutPath = grid => {\n  let newGrid = grid.slice();\n\n  for (let row of grid) {\n    for (let point of row) {\n      let newPoint = { ...point,\n        distance: Infinity,\n        totalDistance: Infinity,\n        isVisited: false,\n        isShortest: false,\n        previousPoint: null\n      };\n      newGrid[point.row][point.col] = newPoint;\n    }\n  }\n\n  return newGrid;\n};\n\nconst updatePointsForRender = (grid, pointsInShortestPathOrder, checkedPointsInOrder) => {\n  let newGrid = grid.slice();\n\n  for (let point of checkedPointsInOrder) {\n    if (point.row === startPointRow && point.col === startPointCol || point.row === endPointRow && point.col === endPointCol) continue;\n    let newPoint = { ...point,\n      isVisited: true\n    };\n    newGrid[point.row][point.col] = newPoint;\n  }\n\n  for (let point of pointsInShortestPathOrder) {\n    if (point.row === endPointRow && point.col === endPointCol) {\n      return newGrid;\n    }\n\n    let newPoint = { ...point,\n      isVisited: false,\n      isShortest: true\n    };\n    newGrid[point.row][point.col] = newPoint;\n  }\n};\n\nexport default App;","map":{"version":3,"sources":["/Users/m/projetfinal/src/App.js"],"names":["React","Component","Node","NavBar","dijkstra","getPointsInShortestPathOrderDijkstra","initialNum","getInitialNum","window","innerWidth","innerHeight","initialNumRows","initialNumColumns","startendPoint","getStartEndPoint","startPointRow","startPointCol","endPointRow","endPointCol","App","state","grid","mouseIsPressed","visualizingAlgorithm","width","height","numRows","numColumns","speed","mazeSpeed","updateDimensions","setState","updateSpeed","path","maze","animateShortestPath","pointsInShortestPathOrder","checkedPointsInOrder","length","i","setTimeout","newGrid","updatePointsForRender","point","document","getElementById","row","col","className","animateAlgorithm","slice","newPoint","isVisited","componentDidMount","addEventListener","getInitialGrid","handleMouseDown","getNewGridWithWalls","handleMouseEnter","handleMouseUp","clearGrid","clearPath","getGridWithoutPath","visualizeDijkstra","startPoint","endPoint","render","bind","map","rowId","pointId","isStart","isFinish","isShortest","isWall","Math","floor","cellWidth","getRandomNums","num","randomNums1","temp","push","randomNums2","randomNums","x","y","random","currentRow","createPoint","distance","Infinity","totalDistance","previousPoint"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport \"./App.css\";\nimport Node from \"./node\";\nimport NavBar from \"./navbar\";\n\n//Algorithms\nimport {\n  dijkstra,\n  getPointsInShortestPathOrderDijkstra,\n} from \"./Algorithm/dijkstra\";\n\n\nconst initialNum = getInitialNum(window.innerWidth, window.innerHeight);\nconst initialNumRows = initialNum[0];\nconst initialNumColumns = initialNum[1];\n\nconst startendPoint = getStartEndPoint(initialNumRows, initialNumColumns);\nconst startPointRow = startendPoint[0];\nconst startPointCol = startendPoint[1];\nconst endPointRow = startendPoint[2];\nconst endPointCol = startendPoint[3];\n\nclass App extends Component {\n  state = {\n    grid: [],\n    mouseIsPressed: false,\n    visualizingAlgorithm: false,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    numRows: initialNumRows,\n    numColumns: initialNumColumns,\n    speed: 10,\n   mazeSpeed: 10,\n  };\n\n  updateDimensions = () => {\n    this.setState({\n      width: window.innerWidth,\n      height: window.innerHeight,\n    });\n  };\n\n  updateSpeed = (path, maze) => {\n    this.setState({ speed: path, mazeSpeed: maze });\n  };\n\n  componentDidMount() {\n    window.addEventListener(\"resize\", this.updateDimensions);\n    const grid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({ grid });\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n    this.setState({ grid: newGrid, mouseIsPressed: true });\n  }\n\n  handleMouseEnter(row, col) {\n    if (this.state.mouseIsPressed) {\n      const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n      this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n  }\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  clearGrid() {\n    if (this.state.visualizingAlgorithm ) {\n      return;\n    }\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (\n            !(\n                (row === startPointRow && col === startPointCol) ||\n                (row === endPointRow && col === endPointCol)\n            )\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false,\n\n    });\n  }\n\n  clearPath() {\n    if (this.state.visualizingAlgorithm ) {\n      return;\n    }\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (\n            document.getElementById(`node-${row}-${col}`).className ===\n            \"node node-shortest-path\"\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getGridWithoutPath(this.state.grid);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false,\n\n    });\n  }\n\n  animateShortestPath = (pointsInShortestPathOrder, checkedPointsInOrder) => {\n    if (pointsInShortestPathOrder.length === 1)\n      this.setState({ visualizingAlgorithm: false });\n    for (let i = 1; i < pointsInShortestPathOrder.length; i++) {\n      if (i === pointsInShortestPathOrder.length - 1) {\n        setTimeout(() => {\n          let newGrid = updatePointsForRender(\n              this.state.grid,\n              pointsInShortestPathOrder,\n              checkedPointsInOrder\n          );\n          this.setState({ grid: newGrid, visualizingAlgorithm: false });\n        }, i * (3 * this.state.speed));\n        return;\n      }\n      let point = pointsInShortestPathOrder[i];\n      setTimeout(() => {\n        //shortest path point\n        document.getElementById(`node-${point.row}-${point.col}`).className =\n            \"node node-shortest-path\";\n      }, i * (3 * this.state.speed));\n    }\n  };\n\n  animateAlgorithm = (checkedPointsInOrder, pointsInShortestPathOrder) => {\n    let newGrid = this.state.grid.slice();\n    for (let row of newGrid) {\n      for (let point of row) {\n        let newPoint = {\n          ...point,\n          isVisited: false,\n        };\n        newGrid[point.row][point.col] = newPoint;\n      }\n    }\n    this.setState({ grid: newGrid });\n    for (let i = 1; i <= checkedPointsInOrder.length; i++) {\n      let point = checkedPointsInOrder[i];\n      if (i === checkedPointsInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(\n              pointsInShortestPathOrder,\n              checkedPointsInOrder\n          );\n        }, i * this.state.speed);\n        return;\n      }\n      setTimeout(() => {\n        //checked point\n        document.getElementById(`node-${point.row}-${point.col}`).className =\n            \"node node-visited\";\n      }, i * this.state.speed);\n    }\n  };\n\n\n  visualizeDijkstra() {\n    if (this.state.visualizingAlgorithm ) {\n      return;\n    }\n    this.setState({ visualizingAlgorithm: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startPoint = grid[startPointRow][startPointCol];\n      const endPoint = grid[endPointRow][endPointCol];\n      const checkedPointsInOrder = dijkstra(grid, startPoint, endPoint);\n      const pointsInShortestPathOrder = getPointsInShortestPathOrderDijkstra(\n          endPoint\n      );\n      this.animateAlgorithm(checkedPointsInOrder, pointsInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n\n\n  render() {\n    let { grid } = this.state;\n    return (\n        <React.Fragment>\n          <NavBar\n              visualizingAlgorithm={this.state.visualizingAlgorithm}\n\n              visualizeDijkstra={this.visualizeDijkstra.bind(this)}\n\n              clearGrid={this.clearGrid.bind(this)}\n              clearPath={this.clearPath.bind(this)}\n              updateSpeed={this.updateSpeed.bind(this)}\n          />\n          <div\n              className={\n                this.state.visualizingAlgorithm\n                    ? \"grid-visualizing\"\n                    : \"grid\"\n              }\n          >\n            {grid.map((row, rowId) => {\n              return (\n                  <div key={rowId}>\n                    {row.map((point, pointId) => {\n                      const {\n                        row,\n                        col,\n                        isStart,\n                        isFinish,\n                        isVisited,\n                        isShortest,\n                        isWall,\n                      } = point;\n                      return (\n                          <Node\n                              key={pointId}\n                              row={row}\n                              col={col}\n                              isStart={isStart}\n                              isFinish={isFinish}\n                              isVisited={isVisited}\n                              isShortest={isShortest}\n                              isWall={isWall}\n                              onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                              onMouseEnter={(row, col) =>\n                                  this.handleMouseEnter(row, col)\n                              }\n                              onMouseUp={() => this.handleMouseUp()}\n                              width={this.state.width}\n                              height={this.state.height}\n                              numRows={this.state.numRows}\n                              numColumns={this.state.numColumns}\n                          ></Node>\n                      );\n                    })}\n                  </div>\n              );\n            })}\n          </div>\n        </React.Fragment>\n    );\n  }\n}\n\nfunction getInitialNum(width, height) {\n  let numColumns;\n  if (width > 1500) {\n    numColumns = Math.floor(width / 25);\n  } else if (width > 1250) {\n    numColumns = Math.floor(width / 22.5);\n  } else if (width > 1000) {\n    numColumns = Math.floor(width / 20);\n  } else if (width > 750) {\n    numColumns = Math.floor(width / 17.5);\n  } else if (width > 500) {\n    numColumns = Math.floor(width / 15);\n  } else if (width > 250) {\n    numColumns = Math.floor(width / 12.5);\n  } else if (width > 0) {\n    numColumns = Math.floor(width / 10);\n  }\n  let cellWidth = Math.floor(width / numColumns);\n  let numRows = Math.floor(height / cellWidth);\n  return [numRows, numColumns];\n}\n\nfunction getRandomNums(num) {\n  let randomNums1 = [];\n  let temp = 2;\n  for (let i = 5; i < num / 2; i += 2) {\n    randomNums1.push(temp);\n    temp += 2;\n  }\n  let randomNums2 = [];\n  temp = -2;\n  for (let i = num / 2; i < num - 5; i += 2) {\n    randomNums2.push(temp);\n    temp -= 2;\n  }\n  return [randomNums1, randomNums2];\n}\n\nfunction getStartEndPoint(numRows, numColumns) {\n  let randomNums;\n  let x;\n  let y;\n  let startPointRow;\n  let startPointCol;\n  let endPointRow;\n  let endPointCol;\n  if (numRows < numColumns) {\n    randomNums = getRandomNums(numRows);\n    x = Math.floor(numRows / 2);\n    y = Math.floor(numColumns / 4);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startPointRow =\n        x + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    startPointCol = y + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    endPointRow =\n        x + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n    endPointCol =\n        numColumns - y + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n  } else {\n    randomNums = getRandomNums(numColumns);\n    x = Math.floor(numRows / 4);\n    y = Math.floor(numColumns / 2);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startPointRow = x + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    startPointCol =\n        y + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    endPointRow = numRows - x + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n    endPointCol =\n        y + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n  }\n  return [startPointRow, startPointCol, endPointRow, endPointCol];\n}\n\nconst getInitialGrid = (numRows, numColumns) => {\n  let grid = [];\n  for (let row = 0; row < numRows; row++) {\n    let currentRow = [];\n    for (let col = 0; col < numColumns; col++) {\n      currentRow.push(createPoint(row, col));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createPoint = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === startPointRow && col === startPointCol,\n    isFinish: row === endPointRow && col === endPointCol,\n    distance: Infinity,\n    totalDistance: Infinity,\n    isVisited: false,\n    isShortest: false,\n    isWall: false,\n    previousPoint: null,\n  };\n};\n\nconst getNewGridWithWalls = (grid, row, col) => {\n  let newGrid = grid.slice();\n  let point = grid[row][col];\n  let newPoint = {\n    ...point,\n    isWall: !point.isWall,\n  };\n  newGrid[row][col] = newPoint;\n  return newGrid;\n};\n\n\nconst getGridWithoutPath = (grid) => {\n  let newGrid = grid.slice();\n  for (let row of grid) {\n    for (let point of row) {\n      let newPoint = {\n        ...point,\n        distance: Infinity,\n        totalDistance: Infinity,\n        isVisited: false,\n        isShortest: false,\n        previousPoint: null,\n      };\n      newGrid[point.row][point.col] = newPoint;\n    }\n  }\n  return newGrid;\n};\n\nconst updatePointsForRender = (\n    grid,\n    pointsInShortestPathOrder,\n    checkedPointsInOrder\n) => {\n  let newGrid = grid.slice();\n  for (let point of checkedPointsInOrder) {\n    if (\n        (point.row === startPointRow && point.col === startPointCol) ||\n        (point.row === endPointRow && point.col === endPointCol)\n    )\n      continue;\n    let newPoint = {\n      ...point,\n      isVisited: true,\n    };\n    newGrid[point.row][point.col] = newPoint;\n  }\n  for (let point of pointsInShortestPathOrder) {\n    if (point.row === endPointRow && point.col === endPointCol) {\n      return newGrid;\n    }\n    let newPoint = {\n      ...point,\n      isVisited: false,\n      isShortest: true,\n    };\n    newGrid[point.row][point.col] = newPoint;\n  }\n};\n\n\nexport default App;\n\n"]},"metadata":{},"sourceType":"module"}