{"ast":null,"code":"export function dijkstra(grid, startPoint, endPoint) {\n  if (!startPoint || !endPoint || startPoint === endPoint) {\n    return false;\n  }\n\n  startPoint.distance = 0;\n  let unvisitedNodes = getPoints(grid);\n  let visitedNodesInOrder = [];\n\n  while (unvisitedNodes.length !== 0) {\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    if (closestNode === endPoint) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n}\n\nfunction getPoints(grid) {\n  let nodes = [];\n\n  for (let row of grid) {\n    for (let node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n  let unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n\n  for (let unvisitedNeighbour of unvisitedNeighbours) {\n    unvisitedNeighbour.distance = node.distance + 1;\n    unvisitedNeighbour.previousPoint = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  let neighbours = [];\n  let {\n    row,\n    col\n  } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter(neighbour => !neighbour.isWall).filter(neighbour => !neighbour.isVisited);\n}\n\nexport function getPointsInShortestPathOrderDijkstra(endPoint) {\n  let nodesInShortestPathOrder = [];\n  let currentPoint = endPoint;\n\n  while (currentPoint !== null) {\n    nodesInShortestPathOrder.unshift(currentPoint);\n    currentPoint = currentPoint.previousPoint;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["/Users/m/projetfinal/src/Algorithm/dijkstra.js"],"names":["dijkstra","grid","startPoint","endPoint","distance","unvisitedNodes","getPoints","visitedNodesInOrder","length","sort","a","b","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbours","nodes","row","node","unvisitedNeighbours","getUnvisitedNeighbours","unvisitedNeighbour","previousPoint","neighbours","col","filter","neighbour","getPointsInShortestPathOrderDijkstra","nodesInShortestPathOrder","currentPoint","unshift"],"mappings":"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","sourcesContent":["export function dijkstra(grid, startPoint, endPoint) {\n    if (!startPoint || !endPoint || startPoint === endPoint) {\n        return false;\n    }\n    startPoint.distance = 0;\n    let unvisitedNodes = getPoints(grid);\n    let visitedNodesInOrder = [];\n    while (unvisitedNodes.length !== 0) {\n        unvisitedNodes.sort((a, b) => a.distance - b.distance);\n        let closestNode = unvisitedNodes.shift();\n        if (closestNode.isWall) continue;\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\n        if (closestNode === endPoint) return visitedNodesInOrder;\n        closestNode.isVisited = true;\n        visitedNodesInOrder.push(closestNode);\n        updateUnvisitedNeighbours(closestNode, grid);\n    }\n}\n\nfunction getPoints(grid) {\n    let nodes = [];\n    for (let row of grid) {\n        for (let node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n    let unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\n        unvisitedNeighbour.distance = node.distance + 1;\n        unvisitedNeighbour.previousPoint = node;\n    }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n    let neighbours = [];\n    let { row, col } = node;\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    return neighbours\n        .filter((neighbour) => !neighbour.isWall)\n        .filter((neighbour) => !neighbour.isVisited);\n}\n\nexport function getPointsInShortestPathOrderDijkstra(endPoint) {\n    let nodesInShortestPathOrder = [];\n    let currentPoint = endPoint;\n    while (currentPoint !== null) {\n        nodesInShortestPathOrder.unshift(currentPoint);\n        currentPoint = currentPoint.previousPoint;\n    }\n    return nodesInShortestPathOrder;\n}\n"]},"metadata":{},"sourceType":"module"}