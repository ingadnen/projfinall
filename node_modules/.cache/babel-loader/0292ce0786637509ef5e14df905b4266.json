{"ast":null,"code":"export function dijkstra(grid, startPoint, endPoint) {\n  if (!startPoint || !endPoint || startPoint === endPoint) {\n    return false;\n  }\n\n  startPoint.distance = 0;\n  let uncheckedPoints = getPoints(grid);\n  let checkedPointsInOrder = [];\n\n  while (uncheckedPoints.length !== 0) {\n    uncheckedPoints.sort((a, b) => a.distance - b.distance);\n    let nearestPoint = uncheckedPoints.shift();\n    if (nearestPoint.distance === Infinity) return checkedPointsInOrder;\n    if (nearestPoint === endPoint) return checkedPointsInOrder;\n    nearestPoint.isChecked = true;\n    checkedPointsInOrder.push(nearestPoint);\n    updateUncheckedNeighbours(nearestPoint, grid);\n  }\n}\n\nfunction getPoints(grid) {\n  let points = [];\n\n  for (let row of grid) {\n    for (let point of row) {\n      points.push(point);\n    }\n  }\n\n  return points;\n}\n\nfunction updateUncheckedNeighbours(point, grid) {\n  let uncheckedNeighbours = getUncheckedNeighbours(point, grid);\n\n  for (let uncheckedNeighbour of uncheckedNeighbours) {\n    uncheckedNeighbour.distance = point.distance + 1;\n    uncheckedNeighbour.previousPoint = point;\n  }\n}\n\nfunction getUncheckedNeighbours(point, grid) {\n  let neighbours = [];\n  let {\n    row,\n    col\n  } = point;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter(neighbour => !neighbour.isChecked);\n}\n\nexport function getPointsInShortestPathOrderDijkstra(endPoint) {\n  let pointsInShortestPathOrder = [];\n  let currentPoint = endPoint;\n\n  while (currentPoint !== null) {\n    pointsInShortestPathOrder.unshift(currentPoint);\n    currentPoint = currentPoint.previousPoint;\n  }\n\n  return pointsInShortestPathOrder;\n}","map":{"version":3,"sources":["/Users/m/projfinal/src/Algorithm/dijkstra.js"],"names":["dijkstra","grid","startPoint","endPoint","distance","uncheckedPoints","getPoints","checkedPointsInOrder","length","sort","a","b","nearestPoint","shift","Infinity","isChecked","push","updateUncheckedNeighbours","points","row","point","uncheckedNeighbours","getUncheckedNeighbours","uncheckedNeighbour","previousPoint","neighbours","col","filter","neighbour","getPointsInShortestPathOrderDijkstra","pointsInShortestPathOrder","currentPoint","unshift"],"mappings":"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","sourcesContent":["export function dijkstra(grid, startPoint, endPoint) {\n    if (!startPoint || !endPoint || startPoint === endPoint) {\n        return false;\n    }\n    startPoint.distance = 0;\n    let uncheckedPoints = getPoints(grid);\n    let checkedPointsInOrder = [];\n    while (uncheckedPoints.length !== 0) {\n        uncheckedPoints.sort((a, b) => a.distance - b.distance);\n        let nearestPoint = uncheckedPoints.shift();\n        if (nearestPoint.distance === Infinity) return checkedPointsInOrder;\n        if (nearestPoint === endPoint) return checkedPointsInOrder;\n        nearestPoint.isChecked = true;\n        checkedPointsInOrder.push(nearestPoint);\n        updateUncheckedNeighbours(nearestPoint, grid);\n    }\n}\n\nfunction getPoints(grid) {\n    let points = [];\n    for (let row of grid) {\n        for (let point of row) {\n            points.push(point);\n        }\n    }\n    return points;\n}\n\nfunction updateUncheckedNeighbours(point, grid) {\n    let uncheckedNeighbours = getUncheckedNeighbours(point, grid);\n    for (let uncheckedNeighbour of uncheckedNeighbours) {\n        uncheckedNeighbour.distance = point.distance + 1;\n        uncheckedNeighbour.previousPoint = point;\n    }\n}\n\nfunction getUncheckedNeighbours(point, grid) {\n    let neighbours = [];\n    let { row, col } = point;\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    return neighbours\n        .filter((neighbour) => !neighbour.isChecked);\n}\n\nexport function getPointsInShortestPathOrderDijkstra(endPoint) {\n    let pointsInShortestPathOrder = [];\n    let currentPoint = endPoint;\n    while (currentPoint !== null) {\n        pointsInShortestPathOrder.unshift(currentPoint);\n        currentPoint = currentPoint.previousPoint;\n    }\n    return pointsInShortestPathOrder;\n}\n"]},"metadata":{},"sourceType":"module"}