{"ast":null,"code":"export function dijkstra(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n\n  startNode.distance = 0;\n  let unvisitedNodes = getNodes(grid);\n  let visitedNodesInOrder = [];\n\n  while (unvisitedNodes.length !== 0) {\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n}\n\nfunction getNodes(grid) {\n  let nodes = [];\n\n  for (let row of grid) {\n    for (let node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n  let unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n\n  for (let unvisitedNeighbour of unvisitedNeighbours) {\n    unvisitedNeighbour.distance = node.distance + 1;\n    unvisitedNeighbour.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  let neighbours = [];\n  let {\n    row,\n    col\n  } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter(neighbour => !neighbour.isWall).filter(neighbour => !neighbour.isVisited);\n}\n\nexport function getNodesInShortestPathOrderDijkstra(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["/Users/m/projetfinal/src/Algorithm/dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","distance","unvisitedNodes","getNodes","visitedNodesInOrder","length","sort","a","b","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbours","nodes","row","node","unvisitedNeighbours","getUnvisitedNeighbours","unvisitedNeighbour","previousNode","neighbours","col","filter","neighbour","getNodesInShortestPathOrderDijkstra","nodesInShortestPathOrder","currentNode","unshift"],"mappings":"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","sourcesContent":["export function dijkstra(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return false;\n    }\n    startNode.distance = 0;\n    let unvisitedNodes = getNodes(grid);\n    let visitedNodesInOrder = [];\n    while (unvisitedNodes.length !== 0) {\n        unvisitedNodes.sort((a, b) => a.distance - b.distance);\n        let closestNode = unvisitedNodes.shift();\n        if (closestNode.isWall) continue;\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\n        if (closestNode === finishNode) return visitedNodesInOrder;\n        closestNode.isVisited = true;\n        visitedNodesInOrder.push(closestNode);\n        updateUnvisitedNeighbours(closestNode, grid);\n    }\n}\n\nfunction getNodes(grid) {\n    let nodes = [];\n    for (let row of grid) {\n        for (let node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n    let unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\n        unvisitedNeighbour.distance = node.distance + 1;\n        unvisitedNeighbour.previousNode = node;\n    }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n    let neighbours = [];\n    let { row, col } = node;\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    return neighbours\n        .filter((neighbour) => !neighbour.isWall)\n        .filter((neighbour) => !neighbour.isVisited);\n}\n\nexport function getNodesInShortestPathOrderDijkstra(finishNode) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInShortestPathOrder.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}\n"]},"metadata":{},"sourceType":"module"}