{"ast":null,"code":"export function dijkstra(grid, startPoint, endPoint) {\n  if (!startPoint || !endPoint || startPoint === endPoint) {\n    return false;\n  }\n\n  startPoint.distance = 0;\n  let uncheckedPoints = getPoints(grid);\n  let checkedPointsInOrder = [];\n\n  while (uncheckedPoints.length !== 0) {\n    uncheckedPoints.sort((a, b) => a.distance - b.distance);\n    let nearestPoint = uncheckedPoints.shift();\n    if (nearestPoint.isWall) continue;\n    if (nearestPoint.distance === Infinity) return checkedPointsInOrder;\n    if (nearestPoint === endPoint) return checkedPointsInOrder;\n    nearestPoint.isVisited = true;\n    checkedPointsInOrder.push(nearestPoint);\n    updateUnvisitedNeighbours(nearestPoint, grid);\n  }\n}\n\nfunction getPoints(grid) {\n  let points = [];\n\n  for (let row of grid) {\n    for (let node of row) {\n      points.push(node);\n    }\n  }\n\n  return points;\n}\n\nfunction updateUnvisitedNeighbours(point, grid) {\n  let unvisitedNeighbours = getUnvisitedNeighbours(point, grid);\n\n  for (let unvisitedNeighbour of unvisitedNeighbours) {\n    unvisitedNeighbour.distance = point.distance + 1;\n    unvisitedNeighbour.previousPoint = point;\n  }\n}\n\nfunction getUnvisitedNeighbours(point, grid) {\n  let neighbours = [];\n  let {\n    row,\n    col\n  } = point;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter(neighbour => !neighbour.isWall).filter(neighbour => !neighbour.isVisited);\n}\n\nexport function getPointsInShortestPathOrderDijkstra(endPoint) {\n  let pointsInShortestPathOrder = [];\n  let currentPoint = endPoint;\n\n  while (currentPoint !== null) {\n    pointsInShortestPathOrder.unshift(currentPoint);\n    currentPoint = currentPoint.previousPoint;\n  }\n\n  return pointsInShortestPathOrder;\n}","map":{"version":3,"sources":["/Users/m/projetfinal/src/Algorithm/dijkstra.js"],"names":["dijkstra","grid","startPoint","endPoint","distance","uncheckedPoints","getPoints","checkedPointsInOrder","length","sort","a","b","nearestPoint","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbours","points","row","node","point","unvisitedNeighbours","getUnvisitedNeighbours","unvisitedNeighbour","previousPoint","neighbours","col","filter","neighbour","getPointsInShortestPathOrderDijkstra","pointsInShortestPathOrder","currentPoint","unshift"],"mappings":"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","sourcesContent":["export function dijkstra(grid, startPoint, endPoint) {\n    if (!startPoint || !endPoint || startPoint === endPoint) {\n        return false;\n    }\n    startPoint.distance = 0;\n    let uncheckedPoints = getPoints(grid);\n    let checkedPointsInOrder = [];\n    while (uncheckedPoints.length !== 0) {\n        uncheckedPoints.sort((a, b) => a.distance - b.distance);\n        let nearestPoint = uncheckedPoints.shift();\n        if (nearestPoint.isWall) continue;\n        if (nearestPoint.distance === Infinity) return checkedPointsInOrder;\n        if (nearestPoint === endPoint) return checkedPointsInOrder;\n        nearestPoint.isVisited = true;\n        checkedPointsInOrder.push(nearestPoint);\n        updateUnvisitedNeighbours(nearestPoint, grid);\n    }\n}\n\nfunction getPoints(grid) {\n    let points = [];\n    for (let row of grid) {\n        for (let node of row) {\n            points.push(node);\n        }\n    }\n    return points;\n}\n\nfunction updateUnvisitedNeighbours(point, grid) {\n    let unvisitedNeighbours = getUnvisitedNeighbours(point, grid);\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\n        unvisitedNeighbour.distance = point.distance + 1;\n        unvisitedNeighbour.previousPoint = point;\n    }\n}\n\nfunction getUnvisitedNeighbours(point, grid) {\n    let neighbours = [];\n    let { row, col } = point;\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    return neighbours\n        .filter((neighbour) => !neighbour.isWall)\n        .filter((neighbour) => !neighbour.isVisited);\n}\n\nexport function getPointsInShortestPathOrderDijkstra(endPoint) {\n    let pointsInShortestPathOrder = [];\n    let currentPoint = endPoint;\n    while (currentPoint !== null) {\n        pointsInShortestPathOrder.unshift(currentPoint);\n        currentPoint = currentPoint.previousPoint;\n    }\n    return pointsInShortestPathOrder;\n}\n"]},"metadata":{},"sourceType":"module"}