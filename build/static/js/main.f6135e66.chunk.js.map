{"version":3,"sources":["serviceWorker.js","point.jsx","navbar.jsx","Algorithm/dijkstra.js","App.js","index.js"],"names":["Boolean","window","location","hostname","match","Point","props","state","cercleHeight","this","row","col","isStart","isEnd","isChecked","isShortest","width","height","numRows","numColumns","extraClass","cercleWidth","Math","floor","id","className","style","Component","brand","innerWidth","NavBar","algorithm","pathState","speedState","selection","visualizingAlgorithm","setState","visualizeDijkstra","href","type","data-toggle","aria-haspopup","aria-expanded","aria-labelledby","onClick","selectAlgorithm","visualizeAlgorithm","dijkstra","grid","startPoint","endPoint","distance","uncheckedPoints","points","point","push","getPoints","checkedPointsInOrder","length","sort","a","b","nearestPoint","shift","Infinity","updateUncheckedNeighbours","uncheckedNeighbours","neighbours","filter","neighbour","getUncheckedNeighbours","uncheckedNeighbour","previousPoint","initialNum","getInitialNum","innerHeight","initialNumRows","initialNumColumns","startEndPoint","randomNums","x","y","startPointRow","startPointCol","endPointRow","endPointCol","getRandomNums","random","getStartEndPoint","App","speed","updateDimensions","animateShortestPath","pointsInShortestPathOrder","i","setTimeout","newGrid","updatePointsForRender","document","getElementById","animateAlgorithm","slice","newPoint","addEventListener","getInitialGrid","currentPoint","unshift","getPointsInShortestPathOrderDijkstra","Fragment","bind","map","rowId","key","pointId","num","randomNums1","temp","randomNums2","currentRow","createPoint","totalDistance","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.f6135e66.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n\n\nconst isLocalhost = Boolean(\n    window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n              'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n      .register(swUrl)\n      .then(registration => {\n        registration.onupdatefound = () => {\n          const installingWorker = registration.installing;\n          if (installingWorker == null) {\n            return;\n          }\n          installingWorker.onstatechange = () => {\n            if (installingWorker.state === 'installed') {\n              if (navigator.serviceWorker.controller) {\n                // At this point, the updated precached content has been fetched,\n                // but the previous service worker will still serve the older\n                // content until all client tabs are closed.\n                console.log(\n                    'New content is available and will be used when all '\n                );\n\n                // Execute callback\n                if (config && config.onUpdate) {\n                  config.onUpdate(registration);\n                }\n              } else {\n                // At this point, everything has been precached.\n                // It's the perfect time to display a\n                // \"Content is cached for offline use.\" message.\n                console.log('Content is cached for offline use.');\n\n                // Execute callback\n                if (config && config.onSuccess) {\n                  config.onSuccess(registration);\n                }\n              }\n            }\n          };\n        };\n      })\n      .catch(error => {\n        console.error('Error during service worker registration:', error);\n      });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n      .then(response => {\n        // Ensure service worker exists, and that we really are getting a JS file.\n        const contentType = response.headers.get('content-type');\n        if (\n            response.status === 404 ||\n            (contentType != null && contentType.indexOf('javascript') === -1)\n        ) {\n          // No service worker found. Probably a different app. Reload the page.\n          navigator.serviceWorker.ready.then(registration => {\n            registration.unregister().then(() => {\n              window.location.reload();\n            });\n          });\n        } else {\n          // Service worker found. Proceed as normal.\n          registerValidSW(swUrl, config);\n        }\n      })\n      .catch(() => {\n        console.log(\n            'No internet connection found. App is running in offline mode.'\n        );\n      });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n        .then(registration => {\n          registration.unregister();\n        })\n        .catch(error => {\n          console.error(error.message);\n        });\n  }\n}\n","import React, { Component } from \"react\";\nimport \"./point.css\";\n\nclass Point extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {};\n    }\n\n    render() {\n        const {\n            row,\n            col,\n            isStart,\n            isEnd,\n            isChecked,\n            isShortest,\n            width,\n            height,\n            numRows,\n            numColumns,\n        } = this.props;\n\n        const extraClass = isStart\n            ? \"point point-start\"\n            : isEnd\n                ? \"point point-end\"\n                    : isShortest\n                        ? \"point point-shortest-path\"\n                        : isChecked\n                            ? \"point point-checked\"\n                            : \"point\";\n\n        let cercleWidth = Math.floor((width - 15) / numColumns);\n        let cercleHeight;\n        if (width > 1500) {\n            cercleHeight = Math.floor((height - 70) / numRows);\n        } else if (width > 1000) {\n            cercleHeight = Math.floor((height - 70) / numRows);\n        } else if (width > 500) {\n            cercleHeight = Math.floor((height - 60) / numRows);\n        } else if (width > 0) {\n            cercleHeight = Math.floor((height - 50) / numRows);\n        }\n\n        return (\n            <div\n                id={`point-${row}-${col}`}\n                className={`${extraClass}`}\n                style={{ \"--width\": `${cercleWidth}px`, \"--height\": `${cercleHeight}px` }}\n            ></div>\n        );\n    }\n}\n\nexport default Point;\n","import React, { Component } from \"react\";\nimport \"./navbar.css\";\n\nconst brand = window.innerWidth > 600 ? \"Algorithme Dijkstra\" : \"Dijkstra\";\n\nclass NavBar extends Component {\n    state = {\n        algorithm: \"Algorithm Acting\",\n        pathState: false,\n        speedState: \"Speed\",\n    };\n\n    selectAlgorithm(selection) {\n        if (this.props.visualizingAlgorithm) {\n            return;\n        }\n        if (\n            selection === this.state.algorithm ||\n            this.state.algorithm === \"Acting Algorithm\" ||\n            this.state.algorithm === \"Select an Algorithm!\"\n        ) {\n            this.setState({ algorithm: selection });\n        } else if (this.state.pathState) {\n            this.setState({ algorithm: selection });\n        } else {\n            this.setState({ algorithm: selection });\n        }\n    }\n\n\n\n    visualizeAlgorithm() {\n        if (this.props.visualizingAlgorithm ) {\n            return;\n        }\n        if (\n            this.state.algorithm === \"ActingAlgorithm\" ||\n            this.state.algorithm === \"Select an Algorithm!\"\n        ) {\n            this.setState({ algorithm: \"Select an Algorithm!\" });\n        } else {\n            this.setState({ pathState: true });\n            if (this.state.algorithm === \"See Dijkstra\")\n                this.props.visualizeDijkstra();\n        }\n    }\n\n\n    render() {\n        return (\n            <nav className=\"navbar navbar-expand navbar-dark bg-dark\">\n                <a\n                    className=\"navbar-brand h1 mb-0\"\n                    href=\"https://github.com/ingadnen/projetsfinal.git\"\n                >\n                    {brand}\n                </a>\n                <div className=\"navbar-collapse\" id=\"navbarNavDropdown\">\n                    <ul className=\"navbar-nav\">\n                        <li className=\"nav-item dropdown\">\n                            <div className=\"dropdown\">\n                                <button\n                                    className=\"btn btn-light dropdown-toggle\"\n                                    type=\"button\"\n                                    id=\"dropdownMenu1\"\n                                    data-toggle=\"dropdown\"\n                                    aria-haspopup=\"true\"\n                                    aria-expanded=\"false\"\n                                >\n                                    Algorithms\n                                </button>\n                                <div className=\"dropdown-menu\" aria-labelledby=\"dropdownMenu1\">\n                                    <button\n                                        className=\"dropdown-item btn-light\"\n                                        type=\"button\"\n                                        onClick={() => this.selectAlgorithm(\"See Dijkstra\")}\n                                    >\n                                        Dijkstra's Algorithm\n                                    </button>\n\n                                </div>\n                            </div>{\" \"}\n                        </li>\n                        <li>\n                            <button\n                                type=\"button\"\n                                className=\"btn btn-success\"\n                                onClick={() => this.visualizeAlgorithm()}\n                            >\n                                {this.state.algorithm}\n                            </button>\n                        </li>\n\n                    </ul>\n                </div>\n            </nav>\n        );\n    }\n}\nexport default NavBar;\n","export function dijkstra(grid, startPoint, endPoint) {\n    if (!startPoint || !endPoint || startPoint === endPoint) {\n        return false;\n    }\n    startPoint.distance = 0;\n    let uncheckedPoints = getPoints(grid);\n    let checkedPointsInOrder = [];\n    while (uncheckedPoints.length !== 0) {\n        uncheckedPoints.sort((a, b) => a.distance - b.distance);\n        let nearestPoint = uncheckedPoints.shift();\n        if (nearestPoint.distance === Infinity) return checkedPointsInOrder;\n        if (nearestPoint === endPoint) return checkedPointsInOrder;\n        nearestPoint.isChecked = true;\n        checkedPointsInOrder.push(nearestPoint);\n        updateUncheckedNeighbours(nearestPoint, grid);\n    }\n}\n\nfunction getPoints(grid) {\n    let points = [];\n    for (let row of grid) {\n        for (let point of row) {\n            points.push(point);\n        }\n    }\n    return points;\n}\n\nfunction updateUncheckedNeighbours(point, grid) {\n    let uncheckedNeighbours = getUncheckedNeighbours(point, grid);\n    for (let uncheckedNeighbour of uncheckedNeighbours) {\n        uncheckedNeighbour.distance = point.distance + 1;\n        uncheckedNeighbour.previousPoint = point;\n    }\n}\n\nfunction getUncheckedNeighbours(point, grid) {\n    let neighbours = [];\n    let { row, col } = point;\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    return neighbours\n        .filter((neighbour) => !neighbour.isChecked);\n}\n\nexport function getPointsInShortestPathOrderDijkstra(endPoint) {\n    let pointsInShortestPathOrder = [];\n    let currentPoint = endPoint;\n    while (currentPoint !== null) {\n        pointsInShortestPathOrder.unshift(currentPoint);\n        currentPoint = currentPoint.previousPoint;\n    }\n    return pointsInShortestPathOrder;\n}\n","import React, { Component } from \"react\";\nimport \"./App.css\";\nimport Point from \"./point\";\nimport NavBar from \"./navbar\";\n\n\nimport {\n  dijkstra,\n  getPointsInShortestPathOrderDijkstra,\n} from \"./Algorithm/dijkstra\";\n\n\nconst initialNum = getInitialNum(window.innerWidth, window.innerHeight);\nconst initialNumRows = initialNum[0];\nconst initialNumColumns = initialNum[1];\n\nconst startEndPoint = getStartEndPoint(initialNumRows, initialNumColumns);\nconst startPointRow = startEndPoint[0];\nconst startPointCol = startEndPoint[1];\nconst endPointRow = startEndPoint[2];\nconst endPointCol = startEndPoint[3];\n\nclass App extends Component {\n  state = {\n    grid: [],\n    visualizingAlgorithm: false,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    numRows: initialNumRows,\n    numColumns: initialNumColumns,\n    speed: 0.9,\n  };\n\n  updateDimensions = () => {\n    this.setState({\n      width: window.innerWidth,\n      height: window.innerHeight,\n    });\n  };\n  componentDidMount() {\n    window.addEventListener(\"resize\", this.updateDimensions);\n    const grid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({ grid });\n  }\n\n\n  animateShortestPath = (pointsInShortestPathOrder, checkedPointsInOrder) => {\n    if (pointsInShortestPathOrder.length === 1)\n      this.setState({ visualizingAlgorithm: false });\n    for (let i = 1; i < pointsInShortestPathOrder.length; i++) {\n      if (i === pointsInShortestPathOrder.length - 1) {\n        setTimeout(() => {\n          let newGrid = updatePointsForRender(\n              this.state.grid,\n              pointsInShortestPathOrder,\n              checkedPointsInOrder\n          );\n          this.setState({ grid: newGrid, visualizingAlgorithm: false });\n        }, i * (3 * this.state.speed));\n        return;\n      }\n      let point = pointsInShortestPathOrder[i];\n      setTimeout(() => {\n        //shortest path point\n        document.getElementById(`point-${point.row}-${point.col}`).className =\n            \"point point-shortest-path\";\n      }, i * (3 * this.state.speed));\n    }\n  };\n\n  animateAlgorithm = (checkedPointsInOrder, pointsInShortestPathOrder) => {\n    let newGrid = this.state.grid.slice();\n    for (let row of newGrid) {\n      for (let point of row) {\n        let newPoint = {\n          ...point,\n          isChecked: false,\n        };\n        newGrid[point.row][point.col] = newPoint;\n      }\n    }\n    this.setState({ grid: newGrid });\n    for (let i = 1; i <= checkedPointsInOrder.length; i++) {\n      let point = checkedPointsInOrder[i];\n      if (i === checkedPointsInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(\n              pointsInShortestPathOrder,\n              checkedPointsInOrder\n          );\n        }, i * this.state.speed);\n        return;\n      }\n      setTimeout(() => {\n        //checked point\n        document.getElementById(`point-${point.row}-${point.col}`).className =\n            \"point point-visited\";\n      }, i * this.state.speed);\n    }\n  };\n\n\n  visualizeDijkstra() {\n    if (this.state.visualizingAlgorithm ) {\n      return;\n    }\n    this.setState({ visualizingAlgorithm: true });\n    setTimeout(() => {\n      const { grid } = this.state;\n      const startPoint = grid[startPointRow][startPointCol];\n      const endPoint = grid[endPointRow][endPointCol];\n      const checkedPointsInOrder = dijkstra(grid, startPoint, endPoint);\n      const pointsInShortestPathOrder = getPointsInShortestPathOrderDijkstra(\n          endPoint\n      );\n      this.animateAlgorithm(checkedPointsInOrder, pointsInShortestPathOrder);\n    }, this.state.speed);\n  }\n\n\n\n  render() {\n    let { grid } = this.state;\n    return (\n        <React.Fragment>\n          <NavBar\n              visualizingAlgorithm={this.state.visualizingAlgorithm}\n              visualizeDijkstra={this.visualizeDijkstra.bind(this)}\n          />\n          <div\n              className={\n                this.state.visualizingAlgorithm\n                    ? \"grid-see\"\n                    : \"grid\"\n              }\n          >\n            {grid.map((row, rowId) => {\n              return (\n                  <div key={rowId}>\n                    {row.map((point, pointId) => {\n                      const {\n                        row,\n                        col,\n                        isStart,\n                        isEnd,\n                        isChecked,\n                        isShortest,\n                      } = point;\n                      return (\n                          <Point\n                              key={pointId}\n                              row={row}\n                              col={col}\n                              isStart={isStart}\n                              isEnd={isEnd}\n                              isChecked={isChecked}\n                              isShortest={isShortest}\n                              width={this.state.width}\n                              height={this.state.height}\n                              numRows={this.state.numRows}\n                              numColumns={this.state.numColumns}\n                          ></Point>\n                      );\n                    })}\n                  </div>\n              );\n            })}\n          </div>\n        </React.Fragment>\n    );\n  }\n}\n\nfunction getInitialNum(width, height) {\n  let numColumns;\n  if (width > 1500) {\n    numColumns = Math.floor(width / 25);\n  } else if (width > 1250) {\n    numColumns = Math.floor(width / 22.5);\n  } else if (width > 1000) {\n    numColumns = Math.floor(width / 20);\n  } else if (width > 750) {\n    numColumns = Math.floor(width / 17.5);\n  } else if (width > 500) {\n    numColumns = Math.floor(width / 15);\n  } else if (width > 250) {\n    numColumns = Math.floor(width / 12.5);\n  } else if (width > 0) {\n    numColumns = Math.floor(width / 10);\n  }\n  let cercleWidth = Math.floor(width / numColumns);\n  let numRows = Math.floor(height / cercleWidth);\n  return [numRows, numColumns];\n}\n\nfunction getRandomNums(num) {\n  let randomNums1 = [];\n  let temp = 2;\n  for (let i = 5; i < num / 2; i += 2) {\n    randomNums1.push(temp);\n    temp += 2;\n  }\n  let randomNums2 = [];\n  temp = -2;\n  for (let i = num / 2; i < num - 5; i += 2) {\n    randomNums2.push(temp);\n    temp -= 2;\n  }\n  return [randomNums1, randomNums2];\n}\n\nfunction getStartEndPoint(numRows, numColumns) {\n  let randomNums;\n  let x;\n  let y;\n  let startPointRow;\n  let startPointCol;\n  let endPointRow;\n  let endPointCol;\n  if (numRows < numColumns) {\n    randomNums = getRandomNums(numRows);\n    x = Math.floor(numRows / 2);\n    y = Math.floor(numColumns / 4);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startPointRow =\n        x + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    startPointCol = y + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    endPointRow =\n        x + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n    endPointCol =\n        numColumns - y + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n  } else {\n    randomNums = getRandomNums(numColumns);\n    x = Math.floor(numRows / 4);\n    y = Math.floor(numColumns / 2);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startPointRow = x + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    startPointCol =\n        y + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    endPointRow = numRows - x + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n    endPointCol =\n        y + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n  }\n  return [startPointRow, startPointCol, endPointRow, endPointCol];\n}\n\nconst getInitialGrid = (numRows, numColumns) => {\n  let grid = [];\n  for (let row = 0; row < numRows; row++) {\n    let currentRow = [];\n    for (let col = 0; col < numColumns; col++) {\n      currentRow.push(createPoint(row, col));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createPoint = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === startPointRow && col === startPointCol,\n    isEnd: row === endPointRow && col === endPointCol,\n    distance: Infinity,\n    totalDistance: Infinity,\n    isChecked: false,\n    isShortest: false,\n    previousPoint: null,\n  };\n};\n\nconst updatePointsForRender = (\n    grid,\n    pointsInShortestPathOrder,\n    checkedPointsInOrder\n) => {\n  let newGrid = grid.slice();\n  for (let point of checkedPointsInOrder) {\n    if (\n        (point.row === startPointRow && point.col === startPointCol) ||\n        (point.row === endPointRow && point.col === endPointCol)\n    )\n      continue;\n    let newPoint = {\n      ...point,\n      isChecked: true,\n    };\n    newGrid[point.row][point.col] = newPoint;\n  }\n  for (let point of pointsInShortestPathOrder) {\n    if (point.row === endPointRow && point.col === endPointCol) {\n      return newGrid;\n    }\n    let newPoint = {\n      ...point,\n      isChecked: false,\n      isShortest: true,\n    };\n    newGrid[point.row][point.col] = newPoint;\n  }\n};\n\n\nexport default App;\n\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.css\";\nimport \"bootstrap/js/dist/dropdown\";\nimport App from './App';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: serviceWorker(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nserviceWorker.unregister();\n"],"sourceRoot":""}